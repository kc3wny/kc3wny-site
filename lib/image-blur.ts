import fs from 'node:fs'
import path from 'node:path'
import type { ImageMetadata } from './image-utils'

// Re-export client-safe utilities for backward compatibility
export { getContentPathFromSrc, type ImageMetadata } from './image-utils'

// In-memory cache for the current build
const memoryCache = new Map<string, ImageMetadata>()

// Pre-generated image cache (loaded from .image-cache.json)
let imageCache: Record<string, ImageMetadata & { hash?: string; size?: number; optimized?: boolean }> | null = null

/**
 * Load the pre-generated image cache from disk.
 * This cache is generated by scripts/process-images.mjs
 */
function loadImageCache(): Record<string, ImageMetadata & { hash?: string; size?: number; optimized?: boolean }> {
  if (imageCache !== null) return imageCache

  try {
    const cachePath = path.join(process.cwd(), '.image-cache.json')
    if (fs.existsSync(cachePath)) {
      imageCache = JSON.parse(fs.readFileSync(cachePath, 'utf8'))
      return imageCache as Record<string, ImageMetadata & { hash?: string; size?: number; optimized?: boolean }>
    }
  } catch (error) {
    console.warn('Could not load image cache:', error)
  }
  
  imageCache = {}
  return imageCache
}

/**
 * Get blur placeholder and metadata for an image.
 * Uses pre-generated cache for fast builds.
 * Falls back to generating on-demand if cache miss (development).
 */
export async function getImageBlurData(imagePath: string): Promise<ImageMetadata | null> {
  // Normalize path separators for consistent cache keys
  const normalizedPath = imagePath.replace(/\\/g, '/')
  
  // Check memory cache first
  const memoryCached = memoryCache.get(normalizedPath)
  if (memoryCached) return memoryCached

  // Check pre-generated image cache
  const cache = loadImageCache()
  const cached = cache[normalizedPath]
  if (cached && cached.blurDataUrl) {
    const result: ImageMetadata = {
      width: cached.width,
      height: cached.height,
      blurDataUrl: cached.blurDataUrl,
    }
    memoryCache.set(normalizedPath, result)
    return result
  }

  // Cache miss - generate on-demand (slower, for dev or new images)
  // Only import sharp if we actually need to generate
  try {
    const { default: sharp } = await import('sharp')
    const fullPath = path.join(process.cwd(), 'content', imagePath)
    
    if (!fs.existsSync(fullPath)) {
      console.error(`Image not found: ${fullPath}`)
      return null
    }

    const fileBuffer = fs.readFileSync(fullPath)
    const sharpImage = sharp(fileBuffer)
    const metadata = await sharpImage.metadata()
    
    // Handle EXIF orientation
    let width = metadata.width || 800
    let height = metadata.height || 600
    if (metadata.orientation && metadata.orientation >= 5 && metadata.orientation <= 8) {
      [width, height] = [height, width]
    }
    
    // Generate a tiny blurred placeholder (10px wide)
    const blurredBuffer = await sharp(fileBuffer)
      .rotate()
      .resize(10, null, { withoutEnlargement: true })
      .blur(2)
      .jpeg({ quality: 50 })
      .toBuffer()
    
    const blurDataUrl = `data:image/jpeg;base64,${blurredBuffer.toString('base64')}`
    
    const result: ImageMetadata = { width, height, blurDataUrl }
    memoryCache.set(normalizedPath, result)
    
    // Log warning in dev to encourage running the cache script
    if (process.env.NODE_ENV === 'development') {
      console.warn(`⚠️  Blur cache miss for "${normalizedPath}". Run: node scripts/generate-blur-placeholders.js`)
    }
    
    return result
  } catch (error) {
    console.error('Failed to generate blur data:', error)
    return null
  }
}
